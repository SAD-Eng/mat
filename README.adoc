= Memory Atlas Tooling

image:https://gitlab.com/sad-eng/mat/badges/main/pipeline.svg[link="https://gitlab.com/sad-eng/mat/-/commits/main",title="pipeline status"]

== Background

This project provides modeling tools for a "Memory Atlas" model and file format
which describes binary objects. In this context, a "binary object" is describing
data stored in a binary format, regardless of how it is stored. This abstract
"binary object model" can then have multiple "overlays", which provide a way to
represent that abstract model in a concrete format.

Supported formats initially are memory maps and byte streams. Memory maps are
different from byte streams in that they allow (at least somewhat) arbitrary
access, whereas byte streams are typically must be read from start to finish
in order to make sense of them. Examples of memory maps include FPGA and GPU
memory when access from software running on a CPU. Examples of byte streams
include Ethernet packets (e.g. TCP/IP or UDP/IP) and binary files on disk.

This project does not claim to be novel, in fact tools and file formats for
modeling binary data proliferates. For example, arbitrary binary data can be
modeled with https://en.wikipedia
.org/wiki/Data_Format_Description_Language[DFDL]. Memory maps can be described
with https://www.keil.com/pack/doc/CMSIS/SVD/html/index.html[CMSIS SVD].
These are just two of dozens of formats. However, many existing modeling
languages are either tightly coupled with a particular technology.

The goal of this project is to provide tooling that is highly portable and
agnostic to platform, processor type, architecture, programming language,
transport protocol, and so on. However, the supported _overlays_ generated by
the tools will need highly specific details in order to be performant,
idiomatic, and usable. For example, let's say you have an IP in an FPGA which
produces a complex output data type. With these tools, you can model the data
itself, rather than an interface specific technology. What today might be an
AXI stream inside the FPGA could tomorrow need to be placed in Ethernet
packets and sent to an external system, and the day after accessed via memory
map from a Linux driver.

== Installation
Some day soon we will have a PyPI package and/or Windows/Linux executable images.
Until then, install by:

. Install Python 3.8 or greater if you don't already have it
. `git clone <repo URL>`
. `<python> -m venv env` where <python> is:
.. `python3` on Linux
.. `py -3` on Windows
. Activate the new virtual env in `env` with:
.. `source env/bin/activate` on Linux
.. `env\Scripts\activate` on Windows
. `python -m pip install -e .[dev]` to install this project as "editable"
.. This requires pip 21.3 or greater! `python -m pip install --upgrade pip` to
upgrade.
.. Note that the [dev] is optional and installs development dependencies such as
`pytest`, which are not necessary if you only want to run the GUI



== Usage
You can run the GUI with the `mat` command.

You can run the unit tests with `python -m pytest`.

== Support
You can submit issues to the Jira issue tracker for this project:
https://sad-eng.atlassian.net/jira/software/c/projects/MAT/boards/4.
Discussion happens in the SAD Discord server #mat channel, which is invitation
only for now.

== Contributing
This is a public repo for cloning the code and using the tools. The intent is to
allow anyone to submit a merge request. Some members of the SAD group will also
be granted permission to submit changes directly and/or approve merge requests.
Workflow TBD.

== Authors and acknowledgment
Coming soon (once we have authors)

== License
The contents of this repository (source code, scripts, container images, etc
.) are licensed under the GPL. The intent of this is to prevent a third party
forking this source code and building a closed-source tool with it.

To clarify how the GPL works, the GPL does _not_ apply to files and generated
code built by these tools. Any inputs or outputs of these tools are the
intellectual property of the authors of those documents, not of this project,
and they may license or not license those works however they see fit. The GPL
_does_ apply to plugins or templates used with these tools. However, the
authors anticipate that a commercial entity would be unlikely to want to
distribute modified plugins or templates as a commercial product. Rather, they
would hold these to themselves, not distribute any form of them, and use them to
produce artifacts for distribution in any manner they see fit (as per the
previous point).

== Project status
This project is just getting started.
